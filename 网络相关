我们都知道，Web使用了一种名为HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务端等一系列运作流程。而协议是指规则的约定。

现在已经提出的3项WWW构建技术，分别是：把SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的HTML（HyperText Markup Language）；作为文档传递协议的HTTP；指定文档所在地址的URL（Uniform Resource Locator，统一资源定位符）。

WWW这一名称，是Web浏览器当年用来浏览超文本的客户端应用程序时的名称，现在则用来表示这一系列的集合，也可简称为Web。

<br>

### 1. TCP/IP

通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而HTTP属于他内部的一个子集。

TCP/IP协议族里重要的一点就是分层。TCP/IP按层次分别分为以下4层：**应用层，传输层，网络层和数据链路层。**

层次化之后，设计也变的相对简单了。各层接口划分好之后，每个层次内部设计就能够自由改动了。

作用：

- **应用层**：决定了向用户提供应用服务时通信的活动。（TCP/IP协议族内预存了各类通用的应用服务。比如FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类 ，HTTP协议也处于该层）。
- **传输层**：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。（在传输层有2个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议））。
- **网络层**：用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传给对方。与对方计算机之间通过多台计算机火网络设备进行传输时，网络层起的作用就是在众多的选项中选择一条传输路线。
- **数据链路层**：用来处理连接网络的硬件部分。包括控制操作系统，硬件的设备驱动，NIC（网络适配器，即网卡），及光纤等，硬件上的范畴均在链路层的作用范围之内。

举个例子：

客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求；

接着，在传输层（TCP协议）把从应用层收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层；

在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层；

接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层，当传输到应用层，才算真正接收到由客户端发送过来的HTTP请求。

![flowChart](/Users/thinkive/Desktop/Study/MD/网络相关/flowChart.png)



#### 1.1 负责传输的IP协议

按层次分，IP（Internet Protocol）网际协议位于网络层。TCP/IP中的IP就是指的网际协议。IP协议的作用是把各种数据包传给对方。需要满足两个重要的条件：IP地址和MAC地址。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对，IP地址可以变换，但是MAC地址基本上不会更改。

#### 1.2 确保可靠性的TCP协议

按层次分，TCP位于传输层，提供可靠的字节流服务（字节流服务：为了方便，将大块数据分割成以报文段（segment）为单位的数据包进行管理）。TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方，方式就是三次握手策略。

#### 1.3 负责域名解析的DNS服务

DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。他提供域名到IP地址之间的解析服务。



<br>

### 2. HTTP请求与响应

当客户端发起某个请求时，比如：

```java
GET/index.htm HTTP/1.1
Host: hackr.jp
```

GET表示请求服务器的类型，称为方法（method）。随后的字符串/index.htm 指明了请求访问的资源对象，也叫做请求URI（request-URI）。最后的HTTP/1.1是HTTP的版本号。综上即：请求访问某台HTTP服务器上的/index.htm页面资源。

服务端接收到请求后，会将请求内容的处理结果以响应的形式返回：

```java
HTTP/1.1 200 OK
Date: Tue,10 Jul 2017 20:50:15 GMT
Content-Length: 342
Content-Type: text/html

<html>
...
```

响应报文基本上由协议版本，状态码，用以解释状态码的原因短语，可选的响应收不字段以及实体主体构成。



#### 2.1 HTTP是不保存状态的协议

HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存，也就是说再HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。

这样会导致我在当前页面登录了，然后切换了页面，也需要重新登录。于是引入了Cookie。

Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往改服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。

服务器发现客户端发过来的Cookie后，回去检查究竟是从哪个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

<br>

### 3. HTTP信息

#### 3.1 HTTP报文

用于HTTP协议交互的信息被称为HTTP报文。HTTP报文大致可分为报文首部和报文主体两块。通常，并不一定要有报文主体。

#### 3.2 报文主体和实体主体的差异

- **报文（message）**：是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。
- **实体（entity）**：作为请求或响应的有效载荷数据被传输，起内容由实体首部和实体主体组成。

HTTP报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才会导致他和报文主体产生差异。

#### 3.2 压缩传输的内容编码

HTTP协议中有一种被称为内容编码的功能可以实现类似于ZIP压缩文件的操作。

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接受并负责解码。

常用的内容编码有：

1. gzip（GNU zip）
2. compress(UNIX系统的标准压缩)
3. deflate(zlib)
4. identity(不进行编码)

#### 3.3 获取部分内容的范围请求

即断点续传。要实现该功能需要指定下载的实体范围。指定范围发送的请求叫做范围请求（Range Request）。

例如：对一份10000字节大小的资源，可以只请求5001~10000字节内的资源。

![range](/Users/thinkive/Desktop/Study/MD/网络相关/range.png)

针对范围请求，响应会返回状态码为206 Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart/byteranges后返回响应报文。

如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。



<br>

### 4. HTTP状态码

|      | 类型                     | 原因短语          |
| :--: | ---------------------- | ------------- |
| 1XX  | Information（信息性状态码）    | 接收的请求正在处理     |
| 2XX  | Success（成功状态码）         | 请求正常处理完毕      |
| 3XX  | Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务端无法处理请求     |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错     |



下面我们来看看常用的一些状态码：

1. **200 OK** 表示从客户端发来的请求在服务器端被正常处理了。
2. **204 No Content ** 该状态码代表服务器接收的请求已经被成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
3. **206 Partial Content** 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。
4. **301 Moved Permanently** 永久性重定向。该状态码表示请求的资源已被分配给了新的URI，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。
5. **302 Found** 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。
6. **303 See Other** 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET请求方法定向获取请求的资源。
7. **304 Not Modified** 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。
8. **307 Temporary Redirect** 临时重定向。该状态码与302有这相同的含义。307会遵照浏览器标准，不会从POST变成GET。
9. **400 Bad Request** 表示请求报文中存在语法错误。
10. **401 Unauthorized** 表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。另外若之前已经进行过1次请求，则表示用户认证失败。返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。
11. **403 Forbidden** 表示请求资源的访问被服务器拒绝了。
12. **404 Not Found** 表示服务器上无法找到请求的资源。除此之外，也可以在服务端拒绝请求且不想说明理由时使用。
13. **500 Internal Server Error** 表示服务端在执行请求时发生了错误。
14. **503 Service Unavailable** 表明服务端暂时处于超负载或者进行停机维护，现在无法处理请求。

<br>

### 5. Web服务器

一台Web服务器可搭建多个独立域名的Web网站，也可以作为通信路径上的中转服务器提升传输效率。

#### 用单台虚拟主机实现多个域名

即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已经具有多台服务器。

当多个域名部署在同一个服务器上时，使用DNS解析域名后，两者的IP地址是相同的，因此在发送HTTP请求时，必须在Host首部内完整指定主机名火域名的URI。

这里还涉及到几个概念。

- **代理**： 代理是一种具有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色。接受由客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端。
- **网关**： 网关是转发其他服务器通信数据的服务器，接受从客户端发送来的请求时，它就像自己拥有自由的源服务器一样对请求进行处理。又是客户端可能都不会察觉，自己的通信目标是一个网关。
- **隧道**：  隧道是在相隔很远的客户端和服务端之间进行中转，并保持双方通信连接的应用程序。


<br>

### 6. HTTPS

与SSL（Secure Socket Layer，安全套接层）组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）。

HTTP+加密+认证+完整性保护=HTTPS

下面我们来看下HTTPS的通信步骤：

![https](/Users/thinkive/Desktop/Study/MD/网络相关/https.png)

1. 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL指定版本，加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
2. 服务器可进行SSL通信时，会以Server Hello报文作为应答。可客户端一样，在报文中包含SSL版本及加密组件。服务端的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 之后服务器发送Certificate报文。报文中包含公开密钥证书。
4. 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。
5. SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串，该报文已用步骤3中的公钥进行加密。
6. 接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。
7. 客户端发送Finished报文。改报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
8. 服务器同样发送Change Cipher Spec报文。
9. 服务器同样发送Finished报文。
10. 服务器和客户端的Finished报文交换完成之后，SSL连接就算建立完成。当然，通信会收到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。
11. 应用层协议通信，即发送HTTP响应。
12. 最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。

在以上流程中，应用层发送数据时会附加一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否发生篡改，从而保护报文的完整性。

下图为建立HTTPS通信的整个过程：

![https_ process](/Users/thinkive/Desktop/Study/MD/网络相关/https_ process.png)



